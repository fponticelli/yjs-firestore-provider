{"version":3,"file":"index.esm.js","sources":["../node_modules/tslib/tslib.es6.js","../node_modules/lib0/map.js","../node_modules/lib0/set.js","../node_modules/lib0/array.js","../node_modules/lib0/observable.js","../src/time.ts","../src/FirestoreProvider.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template V,K\n * @template {Map<K,V>} MAP\n * @param {MAP} map\n * @param {K} key\n * @param {function():V} createT\n * @return {V}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T}\n */\nexport const first = set =>\n  set.values().next().value || undefined\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => new Set(entries)\n","/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\nimport * as set from './set.js'\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n * @template {ArrayLike<ITEM>} ARR\n *\n * @param {ARR} arr\n * @param {function(ITEM, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @template {ArrayLike<S>} ARR\n * @param {ARR} arr\n * @param {function(S, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => arr.reduce((acc, val) => acc.concat(val), [])\n\nexport const isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nexport const unique = arr => from(set.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nexport const uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = set.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n *\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n","import { FirebaseApp } from \"@firebase/app\";\r\nimport { deleteDoc, doc, getDoc, getFirestore, serverTimestamp, setDoc, Timestamp } from \"@firebase/firestore\";\r\n\r\n/** \r\n * An estimate for the difference in milliseconds between the local clock \r\n * and the server's clock \r\n */\r\nlet delta: number | null = null;\r\n\r\n/**\r\n * Get an approximation of the current server time.\r\n * @param firebaseApp The FirebaseApp\r\n * @param path The path to a document that can be used to get the server time\r\n * @returns An approximation of the current server time\r\n */\r\nexport async function currentTime(firebaseApp: FirebaseApp, path: string) {\r\n    if (delta !== null) {\r\n        return Date.now() + delta;\r\n    }\r\n    try {\r\n        const db = getFirestore(firebaseApp);\r\n        const ref = doc(db, path);\r\n        const before = Date.now();\r\n        await setDoc(ref, {now: serverTimestamp()});\r\n        const after = Date.now();\r\n        const avg = Math.floor((before + after)/2);\r\n        const nowDoc = await getDoc(ref);\r\n        if (nowDoc.exists()) {\r\n            const serverNow = nowDoc.data().now as Timestamp;\r\n            const serverUnixTime = serverNow.seconds*1000 + \r\n                Math.floor(serverNow.nanoseconds/1000000);\r\n    \r\n            delta = serverUnixTime - avg;\r\n            await deleteDoc(ref);\r\n            return Date.now() + delta;\r\n        }\r\n    } catch (error) {\r\n        console.log(\"An error occurred while getting the current time\", {error, path})\r\n    }\r\n\r\n\r\n    // In theory we should never get here, but just in case, fallback\r\n    // to the client time.\r\n    return Date.now();\r\n}\r\n\r\n/**\r\n * Convert a Firestore Timestamp into the number of milliseconds since the\r\n * Unix epoch in UTC time.\r\n * @param timestamp A Firestore Timestamp\r\n * @returns The number of milliseconds since the Unix epoch\r\n */\r\nexport function timeSinceEpoch(timestamp: Timestamp) {\r\n    return  timestamp.seconds*1000 + Math.floor(timestamp.nanoseconds/1000000);\r\n}","import { FirebaseApp } from \"@firebase/app\";\r\nimport { Bytes, collection, deleteDoc, doc, Firestore, getDoc, getDocs, getFirestore, onSnapshot, query, runTransaction, serverTimestamp, setDoc, Timestamp, Unsubscribe, writeBatch } from \"@firebase/firestore\";\r\nimport { Observable } from \"lib0/observable\";\r\nimport * as Y from 'yjs';\r\nimport { currentTime, timeSinceEpoch } from \"./time\";\r\n\r\nconst SHUTDOWN = \"shutdown\";\r\nconst YJS_HISTORY_UPDATES = \"/yjs/history/updates\";\r\nconst YJS_HISTORY = \"/yjs/history\";\r\nconst YJS_TIME = \"/yjs/time\";\r\n\r\ninterface DocUpdate {\r\n    /** A timestamp when the update was saved */\r\n    createdAt: Timestamp | null;\r\n\r\n    /** The binary encoding of the update */\r\n    update: Bytes;\r\n}\r\n\r\nasync function getUpdates(db: Firestore, path: string) {\r\n    const set = new Set<string>();\r\n\r\n\r\n    const ref = collection(db, path);\r\n    const snapshot = await getDocs(ref);\r\n    snapshot.forEach( document => set.add(document.id));\r\n\r\n    return set;\r\n}\r\n\r\nexport async function deleteYjsData(firebaseApp: FirebaseApp, path: string[], updateSet?: Set<string>) {\r\n\r\n    // Save a \"shutdown\" message for all running providers.\r\n    // This is accomplished by adding an empty document whose `id` is \"shutdown\" to the\r\n    // \"updates\" collection.\r\n\r\n    const db = getFirestore(firebaseApp);\r\n\r\n    const basePath = path.join('/');\r\n    const collectionPath = basePath + YJS_HISTORY_UPDATES;\r\n    const shutdownPath = collectionPath + '/' + SHUTDOWN;\r\n    const shutdownRef = doc(db, shutdownPath);\r\n    await setDoc(shutdownRef, {});\r\n\r\n    const baselineRef = doc(db, basePath + YJS_HISTORY);\r\n    \r\n    // If the `updateSet` was not provided, get it via a query\r\n\r\n    if (!updateSet) {\r\n        updateSet = await getUpdates(db, collectionPath);\r\n    }\r\n\r\n    const batch = writeBatch(db);\r\n    batch.delete(baselineRef);\r\n    // Delete all the updates in the set (except for the \"shutdown\" message)\r\n    updateSet.forEach( docId => {\r\n        if (docId !== SHUTDOWN) {\r\n            const docPath = collectionPath + '/' + docId;\r\n            const docRef = doc(db, docPath);\r\n            batch.delete(docRef);\r\n        }\r\n    })\r\n    await batch.commit();\r\n\r\n    // Finally, delete the shutdown message\r\n    await deleteDoc(shutdownRef);\r\n}\r\n\r\ninterface UpdateWithTimestamp {\r\n    time: number;\r\n    update?: Uint8Array;\r\n}\r\n\r\n/**\r\n * Optional configuration settings for FirestoreProvider\r\n */\r\nexport interface FirestoreProviderConfig {\r\n\r\n    /**\r\n     * The maximum number of update events allowed in a blob, set to 20 by default.\r\n     * You can decrease latency by setting this parameter to a lower value. Setting it to 1 will \r\n     * cause the FirestoreProvider to emit every single update event immediately, at the penalty of\r\n     * increased cost due to more frequent writes.\r\n     */\r\n    maxUpdatesPerBlob?: number;\r\n\r\n    /**\r\n     * The maximum amount of time in milliseconds that the user may pause in making \r\n     * changes before a blob is emitted, set to 600 ms by default.  Setting this parameter to a smaller \r\n     * value will reduce latency, but again, at the penalty of increased cost due to more frequent writes.\r\n     * Setting it to a higher value will increase latency and reduce cost.\r\n     */\r\n    maxUpdatePause?: number;\r\n\r\n    /**\r\n     * The maximum amount of time in milliseconds that a blob of updates can live in Firestore\r\n     * before it is removed and merged into the consolidated history. By default, this parameter is set to\r\n     * 10000 (i.e. 10 seconds).  As a best practice, applications should stick with this default.\r\n     */\r\n    blobTimeToLive?: number;\r\n}\r\n\r\n\r\n/**\r\n * A Yjs Provider that stores document updates in a Firestore collection.\r\n */\r\nexport class FirestoreProvider extends Observable<any> {\r\n    readonly doc: Y.Doc;\r\n    error?: Error;\r\n    private firebaseApp: FirebaseApp;\r\n    private unsubscribe?: Unsubscribe;\r\n    private clock = 0;\r\n    private basePath: string;\r\n\r\n    private cache?: Uint8Array;\r\n    private maxUpdatePause = 600;\r\n    private maxUpdatesPerBlob = 20;\r\n\r\n    /**\r\n     * The amount of time that an individual update is allowed to live in the \r\n     * \"updates\" collection until it is merged into \"yjs/baseline\"\r\n     */\r\n    private blobTimeToLive = 10000; // 10 seconds\r\n    private updateCount = 0;\r\n\r\n    /**\r\n     * The id for a timer that will save pending updates after an elapsed time\r\n     */\r\n    private saveTimeoutId?: ReturnType<typeof setTimeout>;\r\n    private compressIntervalId?: ReturnType<typeof setInterval>;\r\n\r\n    private updateHandler: (update: Uint8Array, origin: any) => void;\r\n    private destroyHandler: () => void;\r\n    private updateMap = new Map<string, UpdateWithTimestamp>();\r\n    private isStopped = false;\r\n\r\n    constructor(firebaseApp: FirebaseApp, ydoc: Y.Doc, path: string[], config?: FirestoreProviderConfig) {\r\n        super();\r\n        this.firebaseApp = firebaseApp;\r\n        this.basePath = path.join('/');\r\n        this.doc = ydoc;\r\n\r\n        this.maxUpdatePause =       config?.maxUpdatePause === undefined ? 600   : config.maxUpdatePause;\r\n        this.maxUpdatesPerBlob = config?.maxUpdatesPerBlob === undefined ? 20    : config.maxUpdatesPerBlob;\r\n        this.blobTimeToLive =       config?.blobTimeToLive === undefined ? 10000 : config.blobTimeToLive;\r\n\r\n        const db = getFirestore(firebaseApp);\r\n        const self = this;\r\n\r\n        const extra = Math.floor(2000 * Math.random());\r\n        this.compressIntervalId = setInterval(() => {\r\n            self.compress();\r\n        }, this.blobTimeToLive + extra)\r\n\r\n        this.updateHandler = (update, origin) => {\r\n\r\n            if (this.isStopped) {\r\n                return;\r\n            }\r\n\r\n            // Ignore updates applied by this provider\r\n            if (origin !== self) {\r\n                // The update was produced either locally or by another provider.\r\n                //\r\n                // Don't persist every single update. Instead, merge updates until there are \r\n                // at least 20 changes or there is a pause in updates greater than 600 ms.\r\n                // Merged updates are stored in `this.cache`\r\n\r\n                if (self.saveTimeoutId) {\r\n                    clearTimeout(self.saveTimeoutId);\r\n                    delete self.saveTimeoutId;\r\n                }\r\n                \r\n                self.cache = self.cache ? Y.mergeUpdates([self.cache, update]) : update;\r\n                self.updateCount++;\r\n\r\n                if (self.updateCount < self.maxUpdatesPerBlob) {\r\n                    if (self.saveTimeoutId) {\r\n                        clearTimeout(self.saveTimeoutId);\r\n                    }\r\n                    self.saveTimeoutId = setTimeout(() => {\r\n                        delete self.saveTimeoutId;\r\n                        self.save();\r\n                    }, self.maxUpdatePause)\r\n                } else {\r\n                    self.save();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.destroyHandler = () => this.destroy();\r\n\r\n        // Subscribe to the ydoc's update and destroy events\r\n        ydoc.on('update', this.updateHandler)\r\n        ydoc.on('destroy', this.destroyHandler)\r\n\r\n\r\n        // Start a listener for document updates\r\n        const collectionPath = path.join(\"/\") + YJS_HISTORY_UPDATES;\r\n        const q = query(collection(db, collectionPath));\r\n\r\n        const baselinePath = this.basePath + YJS_HISTORY;\r\n        const baseRef = doc(db, baselinePath);\r\n        getDoc(baseRef).then(baseDoc => {\r\n            if (baseDoc.exists()) {\r\n                const bytes = baseDoc.data().update as Bytes;\r\n                const update = bytes.toUint8Array();\r\n                Y.applyUpdate(ydoc, update, self);\r\n            }\r\n        }).then(()=> {\r\n            self.unsubscribe = onSnapshot(q, (snapshot) => {\r\n                let mustShutdown = false;\r\n                snapshot.docChanges().forEach( change => {\r\n                    const document = change.doc;\r\n    \r\n                    switch (change.type) {\r\n                        case \"added\" :\r\n                        case \"modified\":\r\n                            if (document.id === SHUTDOWN)  {\r\n                                mustShutdown = true;\r\n                                self.updateMap.set(SHUTDOWN, {time: 0});\r\n                            } else {\r\n                                const data = document.data() as DocUpdate;\r\n                                const createdAt = data.createdAt;\r\n                                if (!createdAt) {\r\n                                    break;\r\n                                }\r\n                                const update = data.update.toUint8Array();\r\n                                const clientID = parseClientId(document.id);\r\n                                const time = timeSinceEpoch(createdAt);\r\n                                self.updateMap.set(document.id, {\r\n                                   time,\r\n                                   update\r\n                                })\r\n                                // Ignore updates that originated from the local Y.Doc\r\n                                if (clientID !== ydoc.clientID) {\r\n                                    Y.applyUpdate(ydoc, update, self);\r\n                                }\r\n                            }\r\n                            break;\r\n                        \r\n                        case \"removed\" :\r\n                            self.updateMap.delete(document.id);\r\n                            break;\r\n                    }\r\n                    \r\n                })\r\n                if (mustShutdown) {\r\n                    this.shutdown();\r\n                }\r\n            }, (error) => {\r\n                console.error(`An error occurred while listening for Yjs updates at \"${collectionPath}\"`, error);\r\n                this.error = error;\r\n            })\r\n        }).catch(error => {\r\n            console.error(`An error occurred while getting Yjs update at \"${baselinePath}\"`, error);\r\n        })\r\n\r\n\r\n    }\r\n\r\n    destroy() {\r\n        this.save();\r\n        this.shutdown();\r\n        super.destroy();\r\n    }\r\n\r\n    /**\r\n     * Shutdown this provider, and permanently delete the \r\n     * Yjs data \r\n     */\r\n    async deleteYjsData() {\r\n        this.shutdown();\r\n        const set = new Set<string>(this.updateMap.keys());\r\n        const path = this.basePath.split('/');\r\n        await deleteYjsData(this.firebaseApp, path, set);\r\n    }\r\n\r\n    private async compress() {\r\n        const map = this.updateMap;\r\n        if (this.isStopped || map.size===0) {\r\n            return;\r\n        }\r\n        const baselinePath = this.basePath + YJS_HISTORY;\r\n        const updatesPath = this.basePath + YJS_HISTORY_UPDATES;\r\n        const timePath = this.basePath + YJS_TIME;\r\n        \r\n        const now = await currentTime(this.firebaseApp, timePath);\r\n        const zombies = new Set<string>();\r\n        let newUpdates: Uint8Array | null = null;\r\n        for (const [key, value] of map) {\r\n            if (value) {\r\n                const update = value.update;\r\n                if (!update) {\r\n                    // Shutting down;\r\n                    return;\r\n                }\r\n                if (now - value.time > this.blobTimeToLive) {\r\n                   zombies.add(key);\r\n                   newUpdates = newUpdates ? Y.mergeUpdates([newUpdates, update]) : update;\r\n                }\r\n            }\r\n        }\r\n        if (!newUpdates) {\r\n            return;\r\n        }\r\n        try {\r\n            const db = getFirestore(this.firebaseApp);\r\n            \r\n            await runTransaction(db, async (txn) => {\r\n                const baselineRef = doc(db, baselinePath);\r\n                const baselineDoc = await txn.get(baselineRef);\r\n                let update: Uint8Array | null = null;\r\n                if (baselineDoc.exists())  {\r\n                    const baselineData = baselineDoc.data() as DocUpdate;\r\n                    update = Y.mergeUpdates(\r\n                        [baselineData.update.toUint8Array(), newUpdates!]\r\n                    );\r\n                } else {\r\n                    update = newUpdates;\r\n                }\r\n\r\n                txn.set(baselineRef, {update: Bytes.fromUint8Array(update!)});\r\n                for (const key of zombies) {\r\n                    const ref = doc(db, updatesPath, key);\r\n                    txn.delete(ref);\r\n                }\r\n            })\r\n\r\n        } catch (error) {\r\n            console.error(\"Failed to compress Yjs update\", {error, path: baselinePath})\r\n        }\r\n\r\n        for (const key of zombies) {\r\n            map.delete(key);\r\n        }\r\n    }\r\n\r\n    private shutdown() {\r\n        if (!this.isStopped) {\r\n            this.isStopped = true;\r\n            this.doc.off(\"update\", this.updateHandler);\r\n            this.doc.off(\"destroy\", this.destroyHandler);\r\n            \r\n            if (this.compressIntervalId) {\r\n                clearInterval(this.compressIntervalId);\r\n                delete this.compressIntervalId;\r\n            }\r\n            if (this.saveTimeoutId) {\r\n                clearTimeout(this.saveTimeoutId);\r\n                delete this.saveTimeoutId;\r\n            }\r\n            if (this.unsubscribe) {\r\n                this.unsubscribe();\r\n                delete this.unsubscribe;\r\n            }\r\n            this.updateMap = new Map<string, UpdateWithTimestamp>();\r\n            if (this.cache) {\r\n                delete this.cache;\r\n            }\r\n            this.updateCount=0;\r\n        }\r\n    }\r\n\r\n    private async save() {\r\n        if (this.saveTimeoutId) {\r\n            clearTimeout(this.saveTimeoutId);\r\n            delete this.saveTimeoutId;\r\n        }\r\n        \r\n        const update = this.cache;\r\n        delete this.cache;\r\n        this.updateCount=0;\r\n\r\n        if (update && !this.isStopped) {\r\n            const data = {\r\n                createdAt: serverTimestamp(),\r\n                update: Bytes.fromUint8Array(update)\r\n            }\r\n\r\n            const clock = this.clock++;\r\n            const time = Date.now();\r\n            const updateId = this.doc.clientID.toString(16) + \r\n                \"-\" + clock.toString(16) + '-' + time.toString(16);\r\n\r\n            const db = getFirestore(this.firebaseApp);\r\n            const path = this.basePath + YJS_HISTORY_UPDATES;\r\n            const docRef = doc(db, path, updateId);\r\n            await setDoc(docRef, data);\r\n        }\r\n    }\r\n}\r\n\r\nfunction parseClientId(updateId: string) {\r\n    const dash = updateId.indexOf('-');\r\n    const value = updateId.substring(0, dash);\r\n    return parseInt(value, 16);\r\n}"],"names":["create","map.create","map.setIfUndefined","set.create","array.from"],"mappings":"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"}